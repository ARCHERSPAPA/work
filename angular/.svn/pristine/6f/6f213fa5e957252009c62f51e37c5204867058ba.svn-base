import { Component, OnInit, Input, ViewChild, Output } from '@angular/core';
import { NgbActiveModal } from '@ng-bootstrap/ng-bootstrap';
import { CropperSettings, Bounds, ImageCropperComponent } from 'ngx-img-cropper';

import { RequestService } from '../../service/request.service';
import { Messages } from '../../model/msg';
import { Default } from '../../model/constant';


@Component({
    selector: 'rev-uploader',
    templateUrl: './uploader.component.html',
    styleUrls: ['./uploader.component.scss']
})
export class UploaderComponent implements OnInit {


    @Input() name: string;

    /***上传图片需要的token和上传url***/
    @Input() width: number;
    @Input() height: number;

    /**
     * 获取上传图片数据
     */
    @Input() fileData: any;
    @Output() isVisible = true;
    @Input() size: number = Default.UPLOAD.MAX_SIZE;
    @Input() hasCut: boolean = true;


    public data: any;
    public cropperSettings: CropperSettings;
    public cropperWidth = 0;
    public cropperHeight = 0;

    public MAX_WIDTH = 800;
    public MAX_HEIGHT = 800;

    public msg: string;
    public isClick = false;
    public fileName: string;
    public currentImg: string;

    @ViewChild('cropper', undefined) cropper: ImageCropperComponent;

    constructor(public activeModal: NgbActiveModal,
        private request: RequestService) {

        this.cropperSettings = new CropperSettings();
        this.cropperSettings.minWidth = 10;
        this.cropperSettings.minHeight = 10;

        //打开可以缩放裁剪窗口可裁剪
        this.cropperSettings.keepAspect = false;

        this.cropperSettings.minWithRelativeToResolution = true;
        this.cropperSettings.preserveSize = true;

        this.cropperSettings.canvasWidth = 600;
        this.cropperSettings.canvasHeight = 300;

        this.cropperSettings.croppedWidth = this.cropperWidth ? this.cropperWidth : this.cropperSettings.canvasWidth;
        this.cropperSettings.croppedHeight = this.cropperHeight ? this.cropperHeight : this.cropperSettings.canvasHeight;



        this.cropperSettings.cropperDrawSettings.strokeColor = 'rgba(11,112,175,0.5)';
        this.cropperSettings.cropperDrawSettings.strokeWidth = 1;

        this.cropperSettings.compressRatio = 1;

        this.cropperSettings.noFileInput = true;
        this.cropperSettings.touchRadius = 20;

        this.data = {};


    }

    ngOnInit() {
        this.name = this.name ? this.name : Default.NAME.UPLOAD_IMG;
        const that = this;
        // document.querySelector('.chk').click();
        if (this.fileData) {
            const img: any = new Image();
            const file: File = this.fileData;
            const fileReader: FileReader = new FileReader();
            const size = Math.ceil(file.size / 1024);

            /***10M以内***/
            if (size > 102400) {
                this.showMsg(Messages.UPLOAD.IMG_MAX);
                return;
            }

            fileReader.onload = function (loadEvent: any) {
                img.src = loadEvent.target.result;
                if (that.hasCut) { that.cropper.setImage(img); }

            };

            fileReader.readAsDataURL(file);
        }
    }

    fileChangeListener(e: any) {

        const that = this;
        const img: any = new Image();
        const file: File = e.target.files[0];
        const fileReader: FileReader = new FileReader();
        const size = Math.ceil(file.size / 1024);


        /***10M以内***/
        if (size > 102400) {
            that.showMsg(Messages.UPLOAD.IMG_MAX);
            e.target.value = '';
            return;
        }
        if(size >this.size * 1024){
            that.showMsg(`只能上传${this.size}m以内的图片`);
            e.target.value = '';
            return;
        }
        console.log(file)
        this.fileName=file.name;
        fileReader.onload = function (loadEvent: any) {
            img.src = loadEvent.target.result;
            if (that.hasCut) { that.cropper.setImage(img) } else {
                that.data.image = img.src;
                that.onClickImage(0)
            }
        };

        fileReader.readAsDataURL(file);
        e.target.value = '';
        
    }

    cropped(bounds: Bounds) {
        this.cropperHeight = bounds.bottom - bounds.top;
        this.cropperWidth = bounds.right - bounds.left;
        // console.log(this.cropperSettings);
    }

    onClickImage(click) {
        console.log(this.data)
        const that = this;
        if (that.data.image) {
            that.isClick = true;
            const img: any = new Image();
            img.src = that.data.image;
            img.onload = function () {

                if (this.height > that.MAX_HEIGHT) {
                    this.width *= (that.MAX_HEIGHT / this.height);
                    this.height = that.MAX_HEIGHT;
                }
                if (this.width > that.MAX_WIDTH) {
                    this.height *= (that.MAX_WIDTH / this.width);
                    this.width = that.MAX_WIDTH;
                }
                const canvas: any = document.getElementById('canvas');
                canvas.width = this.width;
                canvas.height = this.height;

                const ctx = canvas.getContext('2d');

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, this.width, this.height);
                this.crossOrigin = '';

                that.data.image = canvas.toDataURL('image/png', 0.5);

                that.request.doPostImg({
                    url: 'token',
                    success: (res => {
                        if (res && res.code == 200) {
                            const token = JSON.parse(res.data).uptoken;
                            const uploadUrl = JSON.parse(res.data).url;
                            // console.log((JSON.parse(res.data)));
                            that.request.doPostQiniu({
                                token: token,
                                url: uploadUrl,
                                img: that.data.image,
                                success: (data => {

                                    // setTimeout(()=>{
                                    that.isClick = false;
                                    if (data && data.key) {
                                        if (click) {
                                            that.activeModal.close({ image: uploadUrl + '/' + data.key + '',fileName:that.fileName });
                                        } else {
                                            that.currentImg = uploadUrl + '/' + data.key + ''
                                        }

                                    } else {
                                   
                                        that.showMsg(Messages.UPLOAD.FAIL);
                                    }
                                    // },3000);

                                }),
                                error: (err => {
                                    // console.log(err);
                                    if (err && click) {
                                        that.isClick = false;
                                        that.showMsg(Messages.UPLOAD.NET_BUSY);
                                    }
                                })
                            });


                        } else {
                            that.isClick = false;
                            that.showMsg(Messages.UPLOAD.NOT_AUTH);
                        }
                    })
                });
            };

        } else {
            that.showMsg(Messages.UPLOAD.EMPTY);
        }
    }
    showMsg(msg) {
        this.msg = msg;
        setTimeout(() => {
            this.msg = null;
        }, 2000);
    }


}
